name: N8N Auto-Restart Workflow

on:
  workflow_dispatch:
    inputs:
      manual_trigger:
        description: 'Manual trigger for testing'
        required: false
        default: 'false'
  schedule:
    # Backup schedule trigger (optional)
    - cron: '0 */6 * * *'  # Every 6 hours as fallback

env:
  DOCKER_IMAGE: n8nio/n8n:latest
  CONTAINER_NAME: n8n-container
  N8N_PORT: 5678
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
  WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  ## Hardcoded Cloudflare Tunnel token (as requested)
  CF_TUNNEL_TOKEN: "eyJhIjoiNGVlMzAwYmI1OGVkYzhlOTM4NWVhNTI0ZmMxMzk5YzciLCJ0IjoiYWU5YjM5MzItMWZiMC00ZWFjLWFmMzEtZmUwZDE4ZjEyYzIwIiwicyI6Ill6RmxOREEwTVRndE5qYzBPUzAwWW1Wa0xUZ3lOV0V0T1RVNE4yVXlNVGRsTmprMyJ9"
  CF_TUNNEL_NAME: ${{ secrets.CF_TUNNEL_NAME }}
  # N8N Environment Variables
  N8N_BASIC_AUTH_ACTIVE: ${{ secrets.N8N_BASIC_AUTH_ACTIVE }}
  N8N_BASIC_AUTH_USER: ${{ secrets.N8N_BASIC_AUTH_USER }}
  N8N_BASIC_AUTH_PASSWORD: ${{ secrets.N8N_BASIC_AUTH_PASSWORD }}
  DB_TYPE: ${{ secrets.DB_TYPE }}
  DB_POSTGRESDB_HOST: ${{ secrets.DB_POSTGRESDB_HOST }}
  DB_POSTGRESDB_PORT: ${{ secrets.DB_POSTGRESDB_PORT }}
  DB_POSTGRESDB_DATABASE: ${{ secrets.DB_POSTGRESDB_DATABASE }}
  DB_POSTGRESDB_USER: ${{ secrets.DB_POSTGRESDB_USER }}
  DB_POSTGRESDB_PASSWORD: ${{ secrets.DB_POSTGRESDB_PASSWORD }}
  DB_POSTGRESDB_SSL_ENABLED: ${{ secrets.DB_POSTGRESDB_SSL_ENABLED }}
  N8N_ENCRYPTION_KEY: ${{ secrets.N8N_ENCRYPTION_KEY }}
  WEBHOOK_URL_TEST: ${{ secrets.WEBHOOK_URL_TEST }}
  N8N_METRICS: ${{ secrets.N8N_METRICS }}
  N8N_LOG_LEVEL: ${{ secrets.N8N_LOG_LEVEL }}

jobs:
  run-n8n:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours (GitHub's max limit)
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Pull and cache N8N Docker image
        run: |
          echo "Pulling N8N Docker image..."
          docker pull ${{ env.DOCKER_IMAGE }}
          
          # Create cache directory
          mkdir -p /tmp/.buildx-cache
          
          # Save image to cache
          docker save ${{ env.DOCKER_IMAGE }} -o /tmp/.buildx-cache/n8n-image.tar
          
          echo "Docker image cached successfully"

      - name: Install Cloudflare Tunnel (cloudflared)
        run: |
          # Download and install cloudflared
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb || true
          # If dpkg failed due to missing deps, attempt apt-get fix
          if ! command -v cloudflared >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -f -y
            sudo dpkg -i cloudflared-linux-amd64.deb || true
          fi
          # Verify installation
          cloudflared version || true

      - name: Send Telegram notification - Service Starting
        run: |
          curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ env.TELEGRAM_CHAT_ID }}" \
            -d text="ðŸš€ N8N Service Starting - Workflow ID: ${{ github.run_id }}"

      - name: Send webhook notification - Service Starting
        run: |
          curl -s -X POST "${{ env.WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "status": "starting",
              "workflow_id": "${{ github.run_id }}",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "message": "N8N service is starting up"
            }'

      - name: Start N8N with PostgreSQL
        run: |
          echo "Starting N8N container with PostgreSQL configuration..."
          
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            -p ${{ env.N8N_PORT }}:5678 \
            -e N8N_BASIC_AUTH_ACTIVE="${{ env.N8N_BASIC_AUTH_ACTIVE }}" \
            -e N8N_BASIC_AUTH_USER="${{ env.N8N_BASIC_AUTH_USER }}" \
            -e N8N_BASIC_AUTH_PASSWORD="${{ env.N8N_BASIC_AUTH_PASSWORD }}" \
            -e DB_TYPE="${{ env.DB_TYPE }}" \
            -e DB_POSTGRESDB_HOST="${{ env.DB_POSTGRESDB_HOST }}" \
            -e DB_POSTGRESDB_PORT="${{ env.DB_POSTGRESDB_PORT }}" \
            -e DB_POSTGRESDB_DATABASE="${{ env.DB_POSTGRESDB_DATABASE }}" \
            -e DB_POSTGRESDB_USER="${{ env.DB_POSTGRESDB_USER }}" \
            -e DB_POSTGRESDB_PASSWORD="${{ env.DB_POSTGRESDB_PASSWORD }}" \
            -e DB_POSTGRESDB_SSL_ENABLED="${{ env.DB_POSTGRESDB_SSL_ENABLED }}" \
            -e N8N_ENCRYPTION_KEY="${{ env.N8N_ENCRYPTION_KEY }}" \
            -e WEBHOOK_URL_TEST="${{ env.WEBHOOK_URL_TEST }}" \
            -e N8N_METRICS="${{ env.N8N_METRICS }}" \
            -e N8N_LOG_LEVEL="${{ env.N8N_LOG_LEVEL }}" \
            -e N8N_HOST="0.0.0.0" \
            -e N8N_PORT="5678" \
            -e N8N_PROTOCOL="http" \
            ${{ env.DOCKER_IMAGE }}
          
          # Wait for container to start
          sleep 30
          
          # Check if container is running
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo "âœ… N8N container started successfully"
            docker logs ${{ env.CONTAINER_NAME }} --tail 200 || true
          else
            echo "âŒ Failed to start N8N container"
            docker logs ${{ env.CONTAINER_NAME }} --tail 200 || true
            exit 1
          fi

      - name: Setup Cloudflare Tunnel (use --token, no credentials file)
        run: |
          echo "Setting up Cloudflare Tunnel using --token (no credentials file)..."
          
          # Create cloudflared dir (kept for config if you want to add hostname mapping)
          mkdir -p ~/.cloudflared
          
          # Create a minimal config if you want to keep hostname routing, WITHOUT credentials-file
          cat > ~/.cloudflared/config.yml << EOF
          ingress:
            - hostname: ${{ env.CF_TUNNEL_NAME }}.yourdomain.com
              service: http://localhost:${{ env.N8N_PORT }}
            - service: http_status:404
          EOF
          
          # Start cloudflared using token directly (no credentials.json)
          # Running in background with nohup so the job can continue.
          nohup cloudflared tunnel run --token "${{ env.CF_TUNNEL_TOKEN }}" > /tmp/cloudflared.log 2>&1 &
          TUNNEL_PID=$!
          echo "TUNNEL_PID=$TUNNEL_PID" >> $GITHUB_ENV
          
          # Small wait to allow tunnel to initialize and log to be written
          sleep 15
          echo "Cloudflared logs (first 200 lines):"
          head -n 200 /tmp/cloudflared.log || true
          echo "âœ… Cloudflare tunnel started (attempted with --token)"

      - name: Health check and send notifications
        run: |
          # Wait for N8N to be fully ready
          echo "Waiting for N8N to be ready..."
          for i in {1..30}; do
            if curl -f -s http://localhost:${{ env.N8N_PORT }}/healthz > /dev/null 2>&1; then
              echo "âœ… N8N is ready and responding"
              break
            elif [ $i -eq 30 ]; then
              echo "âŒ N8N failed to become ready within timeout"
              exit 1
            else
              echo "â³ Attempt $i/30 - N8N not ready yet, waiting..."
              sleep 10
            fi
          done
          
          # Send success notifications
          curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ env.TELEGRAM_CHAT_ID }}" \
            -d text="âœ… N8N Service Started Successfully! Running for 4 hours. Workflow ID: ${{ github.run_id }}"
          
          curl -s -X POST "${{ env.WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "status": "running",
              "workflow_id": "${{ github.run_id }}",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "message": "N8N service is running successfully",
              "tunnel_status": "active",
              "health_check": "passed"
            }'

      - name: Keep alive for 4 hours
        run: |
          echo "ðŸ• Starting 4-hour keep-alive period..."
          
          START_TIME=$(date +%s)
          FOUR_HOURS=$((4 * 60 * 60))  # 4 hours in seconds
          CHECK_INTERVAL=300           # Check every 5 minutes
          
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            REMAINING=$((FOUR_HOURS - ELAPSED))
            
            # Check if 4 hours have passed
            if [ $ELAPSED -ge $FOUR_HOURS ]; then
              echo "â° 4-hour period completed. Time to restart workflow."
              break
            fi
            
            # Health check
            if ! curl -f -s http://localhost:${{ env.N8N_PORT }}/healthz > /dev/null 2>&1; then
              echo "âŒ Health check failed - N8N is not responding"
              
              # Send failure notification
              curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/sendMessage" \
                -d chat_id="${{ env.TELEGRAM_CHAT_ID }}" \
                -d text="âŒ N8N Health Check Failed - Restarting workflow. ID: ${{ github.run_id }}"
              
              exit 1
            fi
            
            # Log progress
            MINUTES_REMAINING=$((REMAINING / 60))
            echo "â³ N8N running healthy. Time remaining: ${MINUTES_REMAINING} minutes"
            
            # Send periodic status update (every 30 minutes)
            if [ $((ELAPSED % 1800)) -eq 0 ] && [ $ELAPSED -gt 0 ]; then
              curl -s -X POST "${{ env.WEBHOOK_URL }}" \
                -H "Content-Type: application/json" \
                -d '{
                  "status": "running",
                  "workflow_id": "${{ github.run_id }}",
                  "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
                  "elapsed_minutes": '$((ELAPSED / 60))',
                  "remaining_minutes": '$MINUTES_REMAINING',
                  "health_status": "healthy"
                }'
            fi
            
            sleep $CHECK_INTERVAL
          done

      - name: Trigger next workflow run
        id: trigger_next
        run: |
          echo "ðŸ”„ Triggering next workflow run..."
          
          # Trigger workflow dispatch
          RESPONSE=$(curl -s -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${{ env.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ github.workflow }}.yml/dispatches" \
            -d '{"ref":"${{ github.ref_name }}","inputs":{"manual_trigger":"auto-restart"}}')
          
          HTTP_CODE="${RESPONSE: -3}"
          
          if [ "$HTTP_CODE" = "204" ]; then
            echo "âœ… Next workflow triggered successfully"
            echo "trigger_success=true" >> $GITHUB_OUTPUT
            
            # Send success notification
            curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d chat_id="${{ env.TELEGRAM_CHAT_ID }}" \
              -d text="ðŸ”„ Next N8N workflow triggered successfully. Current run: ${{ github.run_id }} will now shutdown."
            
            curl -s -X POST "${{ env.WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "status": "workflow_triggered",
                "workflow_id": "${{ github.run_id }}",
                "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
                "message": "Next workflow run triggered successfully"
              }'
          else
            echo "âŒ Failed to trigger next workflow. HTTP Code: $HTTP_CODE"
            echo "trigger_success=false" >> $GITHUB_OUTPUT
            
            # Send failure notification
            curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d chat_id="${{ env.TELEGRAM_CHAT_ID }}" \
              -d text="âŒ Failed to trigger next N8N workflow. HTTP: $HTTP_CODE. Manual intervention required."
          fi

      - name: Verify workflow trigger
        run: |
          if [ "${{ steps.trigger_next.outputs.trigger_success }}" = "true" ]; then
            echo "â³ Waiting 30 seconds to verify new workflow started..."
            sleep 30
            
            # Check if new workflow run started
            LATEST_RUN=$(curl -s -H "Authorization: Bearer ${{ env.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ github.workflow }}.yml/runs?per_page=1" \
              | jq -r '.workflow_runs[0].id')
            
            if [ "$LATEST_RUN" != "${{ github.run_id }}" ]; then
              echo "âœ… New workflow run detected: $LATEST_RUN"
              
              curl -s -X POST "${{ env.WEBHOOK_URL }}" \
                -H "Content-Type: application/json" \
                -d '{
                  "status": "verified",
                  "old_workflow_id": "${{ github.run_id }}",
                  "new_workflow_id": "'$LATEST_RUN'",
                  "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
                  "message": "Workflow succession verified successfully"
                }'
            else
              echo "âš ï¸ Could not verify new workflow run"
            fi
          else
            echo "âŒ Previous trigger failed, skipping verification"
          fi

      - name: Graceful shutdown
        if: always()
        run: |
          echo "ðŸ›‘ Starting graceful shutdown..."
          
          # Stop Cloudflare tunnel
          if [ ! -z "${TUNNEL_PID:-}" ]; then
            echo "Stopping Cloudflare tunnel (PID: $TUNNEL_PID)..."
            kill -TERM $TUNNEL_PID 2>/dev/null || true
            sleep 5
            kill -KILL $TUNNEL_PID 2>/dev/null || true
          fi
          
          # Stop N8N container gracefully
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo "Stopping N8N container gracefully..."
            docker stop ${{ env.CONTAINER_NAME }} --time=30 || true
            docker rm ${{ env.CONTAINER_NAME }} || true
            echo "âœ… N8N container stopped and removed"
          fi
          
          # Clean up Docker images to save space
          docker system prune -f || true
          
          # Send shutdown notifications
          curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ env.TELEGRAM_CHAT_ID }}" \
            -d text="ðŸ›‘ N8N Service Shutdown Complete - Workflow ID: ${{ github.run_id }}"
          
          curl -s -X POST "${{ env.WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "status": "shutdown",
              "workflow_id": "${{ github.run_id }}",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "message": "N8N service shutdown completed gracefully"
            }'
          
          echo "âœ… Graceful shutdown completed"

      - name: Final status report
        if: always()
        run: |
          echo "ðŸ“Š Final Status Report:"
          echo "Workflow ID: ${{ github.run_id }}"
          echo "Start time: ${{ github.event.created_at }}"
          echo "End time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Trigger success: ${{ steps.trigger_next.outputs.trigger_success }}"
          
          # Send final status to webhook
          curl -s -X POST "${{ env.WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "status": "completed",
              "workflow_id": "${{ github.run_id }}",
              "start_time": "${{ github.event.created_at }}",
              "end_time": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "trigger_success": "${{ steps.trigger_next.outputs.trigger_success }}",
              "message": "Workflow cycle completed"
            }'
